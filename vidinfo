#!/bin/bash

args=("$@")
startTime=$(date +%s.%N)
script="$(basename "$0")"
dbPath="${YTPATH:-.}"		# set the YTPATH env var
dbFile="$dbPath/videos.db"
declare -a videos
declare -a result
declare -i cachedCnt=0
declare -i processedCnt=0

metaFile=$(mktemp)	# tmp file for the matching videos

format=$'General;%OverallBitRate/String%,%Duration/String2%,%Duration%,%FileSize/String%,%CompleteName%,%Format%,\n'
format+='Video;%Width%x%Height%,%FrameRate%fps,%CodecID%,'

usage() {
	cat <<-DOC
	Usage: $script [options] [regex]

	Processes video files from either a regex search or standard input.
	Prints out metadata (bit rate, duration, size, filename, resolution, fps, codec).

	Options:
        -d, --duration <secs>   filter videos longer than <secs> seconds
        -t, --tag               assign a tag to a username in the db

	Requires: fd, mpv, mediainfo

	Examples:
        $script peach
        $script -d 600 peach    # videos longer than 600s (10 mins)
        $script ''              # to populate an empty database
        $script -t              # list all tags. Show DB schema
        $script -t <usr>        # lookup all tags for a username (DB)
        $script -t <tag> <usr>  # assign a tag to a username (DB)
        fd --changed-within=1m | $script
DOC
}

calcEndTime() {
	endTime=$(date +%s.%N)
	elapsedTime=$(echo "$endTime - $startTime" | bc)
	printf "Time elapsed: %.1f seconds\n" $elapsedTime
}

requires() {
	local missing=()
	local cmd

	for cmd in "$@"; do
		command -v "$cmd" &>/dev/null || missing+=("$cmd")
	done

	if ((${#missing[@]} > 0)); then
		echo "Missing required commands:"
		printf '\t%s\n' "${missing[@]}"
		exit 1
	fi
}

retypeCMD() {
	local interactiveShell
	local opt=""

	interactiveShell=$(ps -o comm= -p $PPID)

	if [[ ${args[0]} == -* ]]; then
		opt="${args[0]} "
	fi

	if [[ $interactiveShell == zsh ]]; then
		{ sleep 0.1; xdotool type "$(basename ${BASH_SOURCE}) $opt" ;} &
	elif [[ $interactiveShell == bash ]]; then
		xdotool type "$(basename ${BASH_SOURCE}) $opt" &>/dev/null & disown
	fi
}

getName() {
	local file=$1
	if [[ $file =~ ^https?:// ]]; then
		name=$(basename "$file")
	else
		name="${file#/}"
		name="${name%/}"
	fi

	echo "$name"
}

initDB() {
	if [[ ! -f "$dbFile" ]]; then
		sqlite3 "$dbFile" "
		CREATE TABLE users (
			username TEXT PRIMARY KEY
		);

		CREATE TABLE tags (
			tag TEXT PRIMARY KEY
		);

		CREATE TABLE usertags (
			username TEXT,
			tag TEXT,
			PRIMARY KEY (username, tag),
			FOREIGN KEY (username) REFERENCES users(username) ON DELETE CASCADE,
			FOREIGN KEY (tag) REFERENCES tags(tag) ON DELETE CASCADE
		);

		CREATE TABLE videos (
			hash TEXT PRIMARY KEY,
			file TEXT,
			username TEXT,
			size INTEGER,
			duration INTEGER,
			width INTEGER,
			height INTEGER,
			metadata TEXT,
			FOREIGN KEY (username) REFERENCES users(username)
		);

		CREATE INDEX idx_usertags_tag ON usertags(tag);
		CREATE INDEX idx_usertags_username ON usertags(username);
		CREATE INDEX idx_videos_username ON videos(username);
		" 2>/dev/null
	fi
}

processVideo() {
	local video=$1
	local minDuration=${2:-0} # Optional second argument for minimum duration

	# Skip if the file doesn't exist or is not a file
	[[ -f "$video" ]] || return

	hash=$(head -c 128K "$video" | sha256sum)
	hash=${hash%% *}
	username="${video%% *}"		# Remove everything after first space
	username="$(basename "$username")"

	cachedMetadata=$(sqlite3 -init /dev/null "$dbFile" "select metadata from videos where hash = '$hash'" 2>/dev/null)

	if [[ -n "$cachedMetadata" ]]; then
		((cachedCnt++))
		if ((minDuration > 0)); then
			cacheDur=$(sqlite3 -init /dev/null "$dbFile" "select duration from videos where hash = '$hash'" 2>/dev/null)
			if ((cacheDur >= minDuration)); then
				echo "$cachedMetadata" >> "$metaFile"
				result+=("$video")
			fi
		else
			echo "$cachedMetadata" >> "$metaFile"
			result+=("$video")
		fi
	else
		metadata=$(mediainfo --Output="$format" "$video")

		IFS="," read -r _ _ rawDuration _ _ _ resolution _ <<< "$metadata"
		local dur=${rawDuration%.*}	    # remove decimal
		[[ -z "$dur" ]] && return 1     # skip empty results
		((dur /= 1000))                 # convert to seconds

		if processFile "$metadata" "$video" "$dur"; then
			((processedCnt++))
			if ((dur >= minDuration)); then
				echo "$metadata" >> "$metaFile"
				result+=("$video")
			fi
		else
			echo "Corrupt file: $video"
		fi
	fi
}

processFile() {
	local metadata=$1
	local video=$2  # The full path to the video file
	local dur=$3    # The duration in seconds

	IFS="," read -r _ _ _ _ _ _ resolution _ <<< "$metadata"
	local size=$(stat -c "%s" "$video")
	local width=${resolution%x*}
	local height=${resolution#*x}

	sqlite3 "$dbFile" "insert or ignore into users (username) values ('$username')" 2>/dev/null

	sqlite3 "$dbFile" "insert or replace into
		videos (hash, file, username, size, duration, width, height, metadata)
		values ('$hash', '$video', '$username', $size, $dur, $width, $height, '$metadata')" 2>/dev/null

	return $?
}

findVideos() {
	local name=$1
	local searchPaths=()

	# Check if the environment variable is set and not empty
	if [[ -n "$VIDINFO_DIRS" ]]; then
		IFS=':' read -r -a searchPaths <<< "$VIDINFO_DIRS"
	fi

	mapfile -t videos < <(fd -e mp4 -t f "$name" "${searchPaths[@]}")

	for video in "${videos[@]}"; do
		processVideo "$video"
	done
}

findVideosByDuration() {
	local minDuration=$1
	local name=$2
	mapfile -t videos < <(fd -e mp4 -t f "$name" "${searchPaths[@]}")

	for video in "${videos[@]}"; do
		processVideo "$video" "$minDuration"
	done
}

handleTag() {
	if [[ $# -eq  0 ]]; then
		sqlite3 -init /dev/null "$dbFile" <<-'DOC'
			select tag from tags;
			.print
			select sql from sqlite_master where type = 'table';
		DOC

		return
	fi

	if [[ $# -eq 1 ]]; then
		user=$(getName "$1")
		sqlite3 -batch "$dbFile" "select u.username, group_concat(ut.tag, ', ')
			from users u
			left join usertags ut on ut.username = u.username
			where u.username like '%$user%'
			group by u.username;"

			echo
			findVideos "$user"
			return
	fi

	tag="$1"
	shift

	exists=$(sqlite3 -batch -init /dev/null "$dbFile" "select 1 from tags where tag = '$tag' limit 1")

	if [[ -z "$exists" ]]; then
		read -p "Tag '$tag' not found. Add it? [y,Y] " reply
		echo
		if [[ $reply =~ [yY] ]]; then
			sqlite3 -batch -init /dev/null "$dbFile" "insert into tags (tag) values ('$tag');"
			echo " added tag: $tag"
		else
			return
		fi
	fi

	sqlite3 -batch -init /dev/null "$dbFile" "insert or ignore into tags (tag) values ('$tag');"

	while [[ $# -gt 0 ]]; do
		user=$(getName "$1")

		sqlite3 -batch -init /dev/null "$dbFile" "insert or ignore into users (username) values ('$user');"

		exists=$(sqlite3 -batch -init /dev/null "$dbFile" "select 1 from usertags where username = '$user' and tag = '$tag' limit 1;")

		if [[ -n "$exists" ]]; then
			echo "found: $user -> $tag"
			shift
			continue
		fi

		echo
		read -p "Add '$user' to database? [y,Y] " reply
		if [[ $reply =~ [yY] ]]; then
			sqlite3 -batch -init /dev/null "$dbFile" "insert or ignore into usertags (username, tag) values ('$user', '$tag');"
			echo -e "added: $user -> $tag"
		fi
		shift
	done

	echo
}

if [[ $# -eq 0 && -t 0 ]]; then
	echo -e "Provide a regex or pipe input to the script.\n"
	usage
	exit 1
fi

requires fd mediainfo mpv
trap retypeCMD EXIT

initDB

if [[ $# -eq 0 && ! -t 0 ]]; then
	while IFS= read -r file; do
		processVideo "$file"
	done
else
	while [ $# -gt 0 ]; do
		case $1 in
		-d | --duration)
			shift
			dur=$1
			name=$(getName "$2")
			findVideosByDuration "$dur" "$name"
			break
			;;
		-t | --tag)
			shift
			handleTag "$@"
			;;
		-h | --help)
			usage
			exit
			;;
		*)
			name=$(getName "$1")
			findVideos "$name"
			;;
		esac
		shift
	done
fi

if [[ -s "$metaFile" ]]; then
	vidCount=$(wc -l < "$metaFile")
	column -t -s ',' "$metaFile"
	printf "\n%13s %s files\n" "Used cache:" "$cachedCnt"
	printf "%13s %s files\n" "Processed:" "$processedCnt"
	printf "%13s %s files\n" "Found:" "$vidCount"
	echo
	read -rp "Open files? [y,Y] "
	if [[ $REPLY =~ ^[yY]$ ]]; then
		mpv "${result[@]}" &>/dev/null &
	fi
else
	echo -e "No videos found\n"
fi

calcEndTime
