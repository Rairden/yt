#!/bin/bash

startTime=$(date +%s.%N)
script="$(basename "$0")"
dbPath=$ytpath	# env var
dbFile="$dbPath/videos.db"
ARGC=$#
declare -a videos
declare -a result
declare -i cachedCnt=0
declare -i processedCnt=0

metaFile=$(mktemp)	# tmp file for the matching videos

format=$'General;%OverallBitRate/String%,%Duration/String2%,%Duration%,%FileSize/String%,%CompleteName%,%Format%,\n'
format+='Video;%Width%x%Height%,%FrameRate%fps,%CodecID%,'

usage() {
	cat <<-DOC
	Usage: $script [options] [regex]

	Processes video files from either a regex search or standard input.
	Prints out metadata (bit rate, duration, size, filename, resolution, fps, codec).

	Options:
        -d, --duration <secs>   filter videos longer than <secs> seconds
        -t, --tag               assign a tag to a username in the db

	Requires: fd, mpv, mediainfo

	Examples:
        $script peach
        $script -d 600 peach    # videos longer than 600s (10 mins)
        $script ''              # to populate an empty database
        $script -t <tag> <usr>  # assign a tag to a username
        fd --changed-within=1m | $script
DOC
}

calcEndTime() {
	endTime=$(date +%s.%N)
	elapsedTime=$(echo "$endTime - $startTime" | bc)
	printf "Time elapsed: %.1f seconds\n" $elapsedTime
}

requires() {
	if ! command -v "$1" &>/dev/null; then
		echo "Requires $1"
		exit 1
	fi
}

retypeCMD() {
	interactiveShell=$(ps -o comm= -p $PPID)

	if [[ $interactiveShell == zsh ]]; then
		{ sleep 0.1; xdotool type "$(basename ${BASH_SOURCE}) " ;} &
	elif [[ $interactiveShell == bash ]]; then
		xdotool type "$(basename ${BASH_SOURCE}) " &>/dev/null & disown
	fi
}

getName() {
	local file=$1
	if [[ $file =~ ^https?:// ]]; then
		name=$(basename "$file")
	else
		name="${file#/}"
		name="${name%/}"
	fi

	echo "$name"
}

initDB() {
	if [[ ! -f "$dbFile" ]]; then
		sqlite3 "$dbFile" "
		CREATE TABLE users (
			username TEXT PRIMARY KEY
		);

		CREATE TABLE tags (
			tag TEXT PRIMARY KEY
		);

		CREATE TABLE usertags (
			username TEXT,
			tag TEXT,
			PRIMARY KEY (username, tag),
			FOREIGN KEY (username) REFERENCES users(username) ON DELETE CASCADE,
			FOREIGN KEY (tag) REFERENCES tags(tag) ON DELETE CASCADE
		);

		CREATE TABLE videos (
			hash TEXT PRIMARY KEY,
			file TEXT,
			username TEXT,
			size INTEGER,
			duration INTEGER,
			width INTEGER,
			height INTEGER,
			metadata TEXT,
			FOREIGN KEY (username) REFERENCES users(username)
		);

		CREATE INDEX idx_usertags_tag ON usertags(tag);
		CREATE INDEX idx_usertags_username ON usertags(username);
		CREATE INDEX idx_videos_username ON videos(username);
		" 2>/dev/null
	fi
}

processVideo() {
	local video=$1
	local minDuration=${2:-0} # Optional second argument for minimum duration

	# Skip if the file doesn't exist or is not a file
	[[ -f "$video" ]] || return

	hash=$(head -c 128K "$video" | sha256sum)
	hash=${hash%% *}
	username="${video%% *}"		# Remove everything after first space
	username="$(basename "$username")"

	cachedMetadata=$(sqlite3 -init /dev/null "$dbFile" "select metadata from videos where hash = '$hash'" 2>/dev/null)

	if [[ -n "$cachedMetadata" ]]; then
		((cachedCnt++))
		if ((minDuration > 0)); then
			cacheDur=$(sqlite3 -init /dev/null "$dbFile" "select duration from videos where hash = '$hash'" 2>/dev/null)
			if ((cacheDur >= minDuration)); then
				echo "$cachedMetadata" >> "$metaFile"
				result+=("$video")
			fi
		else
			echo "$cachedMetadata" >> "$metaFile"
			result+=("$video")
		fi
	else
		metadata=$(mediainfo --Output="$format" "$video")

		IFS="," read -r _ _ rawDuration _ _ _ resolution _ <<< "$metadata"
		local dur=${rawDuration%.*}	    # remove decimal
		[[ -z "$dur" ]] && return 1     # skip empty results
		((dur /= 1000))                 # convert to seconds

		if processFile "$metadata" "$video" "$dur"; then
			((processedCnt++))
			if ((dur >= minDuration)); then
				echo "$metadata" >> "$metaFile"
				result+=("$video")
			fi
		else
			echo "Corrupt file: $video"
		fi
	fi
}

processFile() {
	local metadata=$1
	local video=$2  # The full path to the video file
	local dur=$3    # The duration in seconds

	IFS="," read -r _ _ _ _ _ _ resolution _ <<< "$metadata"
	local size=$(stat -c "%s" "$video")
	local width=${resolution%x*}
	local height=${resolution#*x}

	sqlite3 "$dbFile" "insert or ignore into users (username) values ('$username')" 2>/dev/null

	sqlite3 "$dbFile" "insert or replace into
		videos (hash, file, username, size, duration, width, height, metadata)
		values ('$hash', '$video', '$username', $size, $dur, $width, $height, '$metadata')" 2>/dev/null

	return $?
}

findVideos() {
	local name=$1
	local searchPaths=()

	# Check if the environment variable is set and not empty
	if [[ -n "$VIDINFO_DIRS" ]]; then
		IFS=':' read -r -a searchPaths <<< "$VIDINFO_DIRS"
	else
		searchPaths+=(".")
	fi

	mapfile -t videos < <(fd -e mp4 -t f "$name" "${searchPaths[@]}")

	for video in "${videos[@]}"; do
		processVideo "$video"
	done
}

findVideosByDuration() {
	local minDuration=$1
	local name=$2
	mapfile -t videos < <(fd -e mp4 -t f "$name" "${searchPaths[@]}")

	for video in "${videos[@]}"; do
		processVideo "$video" "$minDuration"
	done
}

if [[ $# -eq 0 && -t 0 ]]; then
	echo -e "Provide a regex or pipe input to the script.\n"
	usage
	exit 1
fi

requires fd
requires mediainfo
requires mpv
trap retypeCMD EXIT

initDB

if [[ $ARGC -eq 0 && ! -t 0 ]]; then
	while IFS= read -r file; do
		processVideo "$file"
	done
else
	while [ $# -gt 0 ]; do
		case $1 in
		-d | --duration)
			shift
			dur=$1
			name=$(getName "$2")
			findVideosByDuration "$dur" "$name"
			break
			;;
		-t | --tag)
			shift
			if [[ $# -lt 2 ]]; then
				echo -e "need at least: tag + one user\n"
				usage
				exit 1
			fi
			tag="$1"
			shift

			sqlite3 -batch "$dbFile" "insert or ignore into tags (tag) values ('$tag');"

			while [[ $# -gt 0 ]]; do
				user="$1"
				sqlite3 -batch "$dbFile" "insert or ignore into users (username) values ('$user');"
				rows=$(sqlite3 -batch -init /dev/null "$dbFile" \
				"insert or ignore into usertags (username, tag) values ('$user', '$tag'); select changes();")

				if ((rows == 1)); then
					echo " added: $user -> $tag"
				else
					echo "exists: $user -> $tag"
				fi
				shift
			done
			exit
			;;
		-h | --help)
			usage
			exit
			;;
		*)
			name=$(getName "$1")
			findVideos "$name"
			;;
		esac
		shift
	done
fi

if [[ -s "$metaFile" ]]; then
	vidCount=$(wc -l < "$metaFile")
	column -t -s ',' "$metaFile"
	printf "\n%13s %s files\n" "Used cache:" "$cachedCnt"
	printf "%13s %s files\n" "Processed:" "$processedCnt"
	printf "%13s %s files\n" "Found:" "$vidCount"
	echo
	read -rp "Open files? [y,Y] "
	if [[ $REPLY =~ ^[yY]$ ]]; then
		mpv "${result[@]}" &>/dev/null &
	fi
else
	echo -e "No videos found\n"
fi

calcEndTime
