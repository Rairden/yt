#!/bin/bash

script="$(basename "$0")"
url=
resolution=
cookies=false
logfile=$HOME/scratch/yt.log
runningRegexFile=/tmp/re.txt
runningRegex='.*http'
log=/tmp/ytmonitor.log
startTime=$(($(date +%s%N)/1000000))

sanitizeFileName=(
	"--replace-in-metadata" title '[\U00010000-\U0010ffff]' ''  # remove emojis (range 65,536 - 1,114,111)
	"--replace-in-metadata" title "'" ''                        # remove single quotes
	"--replace-in-metadata" title '^\s+|\s+$' ''                # trim whitespace before/after title
)

usage() {
	cat <<-DOC
	Usage: $script [OPTIONS] [-b FILE] [url]

	Download live streams from youtube, twitch, etc.

	If you get a 403 forbidden, login with a web browser and use $script -c <url>

	Options:
        -s, --suspended         show suspended processes
            --recent            lists the two most recently suspended and running process
            --resume            resume recently suspended
        -k, --killall           kill all suspended processes
        -f, --forcekill         kill all processes w/out prompting
        -p, --pause             pause the most recent running process
            --pauseall          pause all running processes
        -g, --grep              search for running processes
        -d, --del               cleans up .temp files less than x hours old
        -t, --show-temp         shows .temp files in the past 1 day
        -c, --cookies           use cookies with a web browser (CAPTCHA, or login required)
        -b, --batch-file FILE   file containing URLs to download
        -r, --resolution        set the maximum resolution
            --recent-pids       returns two pids [recentRunning recentSuspend]
            --swap              swaps the most recently suspended and running process
DOC
}

# gets elapsed time in milliseconds (since start of script)
elapsedTime() {
	local currTime=$(($(date +%s%N)/1000000))
	local elapsed=$((currTime - startTime))
	printf "%s" "$elapsed"
}

log() {
	elapsed=$(elapsedTime)

	local minutes=$((elapsed / 60000))
	local seconds=$(((elapsed % 60000) / 1000))
	mmss=$(printf "%02d:%02d" "$minutes" "$seconds")

	str=$(printf "%25s    %7s  %s  %10s  %s" "$(date --iso-8601=seconds)" "$elapsed" "$mmss" "yt-dlp" "$url")

	if [[ ! -f $logfile ]]; then
		printf "# Measuring the time taken by --get-filename to initiate the download.\n" > "$logfile"
		printf "# While yt-dlp has a faster download speed, youtube-dl is quicker to start and terminate.\n\n" >> "$logfile"
		printf "%25s    %7s  mm:ss  %10s  url\n" "datetime" "ms" "binary" >> "$logfile"
	fi

	printf "%s\n" "$str" >> "$logfile"
}

isYoutubeURL() {
	url=$1
	# https://regex101.com/r/vHEc61/1
	validURL="^((?:https?:)?\/\/)?((?:www|m)\.)?((?:youtube(-nocookie)?\.com|youtu.be))(\/(?:[\w\-]+\?v=|embed\/|v\/)?)([\w\-]+)(\S+)?$"
	echo "$url" | grep -Pq "$validURL"
	return $?
}

start() {
	yt-dlp "$@" -o "%(title)s.%(ext)s" "$url" &>/dev/null
}

download() {
	filename=$(yt-dlp --no-warnings --print filename -o "%(title)s.%(ext)s" "$url")
	[ -z "$filename" ] && echo "filename not found" && exit 3

	setsid suspended-monitor $$ &> /dev/null &
	MONITOR_PID=$!
	trap 'kill -USR1 $MONITOR_PID' EXIT
	trap 'printf "\033]30;ch\007"' EXIT INT

	local args=("${sanitizeFileName[@]}")

	if $cookies; then
		# login to their website using a browser. Then paste your browser user-agent into here.
		userAgent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36"
		args+=('--cookies-from-browser' chrome '--user-agent' "$userAgent")
		filename=$(yt-dlp "${args[@]}" --print filename "$url")
		[ -z "$filename" ] && echo "filename not found" && exit 3
	fi

	log
	printf "\033]30;%s\007" "${filename:0:7}"	# rename Konsole tab

	addFormatArgs args
	start "${args[@]}"
}

downloadWithQuality() {
	local args=("${sanitizeFileName[@]}")
	addFormatArgs args
	start "${args[@]}"
}

addFormatArgs() {
	# This uses a "nameref" to modify the 'args' array from the calling function.
	local -n _args=$1

	local formatStr
	if [ -n "$resolution" ]; then
		formatStr="bestvideo[height<=$resolution][ext=mp4]+bestaudio[ext=m4a]/best[height<=$resolution][ext=mp4]/best"
	else
		formatStr="bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best"
	fi

	_args+=(-f "$formatStr")
}

batchDownload() {
	file=$1
	if [[ ! -f $file ]]; then
		echo "Error: File '$file' does not exist."
		return 1
	fi

	while read -r url; do
		[[ $url =~ ^# ]] && continue
		downloadWithQuality
	done < "$file" | sort -u
}

requires() {
	if ! command -v "$1" &>/dev/null; then
		echo "Requires $1"
		exit 1
	fi
}

getRecentProcessStates() {
	declare -A killedPIDs
	local recentRunning recentSuspend penultimateRunning state

	while read -r date _ _ pid state _; do
		[[ $date =~ ^# ]] && continue

		if [[ -v killedPIDs[$pid] ]]; then
			continue
		fi

		if [[ -z $recentRunning && $state == running ]]; then
			recentRunning=$pid
		elif [[ -n $recentRunning && -z $penultimateRunning && $state == running && $pid -ne $recentRunning ]]; then
			penultimateRunning=$pid
		elif [[ -z $recentSuspend && $state == suspended ]]; then
			recentSuspend=$pid
		elif [[ $state == killed ]]; then
			killedPIDs[$pid]=
		fi

		if [[ -n $recentRunning && -n $recentSuspend && -n $penultimateRunning ]]; then
			break
		fi

	done < <(tac "$log" 2>/dev/null)

	echo "${recentRunning:-0} ${recentSuspend:-0} ${penultimateRunning:-0}"
}

# Swaps the most recently suspended and running process
swapActiveSuspended() {
	local recentRunning recentSuspend

	runningProcs=$(pgrep -afc "$script $runningRegex" -r S)
	if ((runningProcs < 1)); then
		echo "Error: at least 1 running process is required to perform a swap."
		return 1
	fi

	read -r recentRunning recentSuspend _ <<< "$(getRecentProcessStates)"

	suspendedProcessName=$(ps -p "$recentSuspend" -o args= | awk '{print $NF}')
	runningProcessName=$(ps -p "$recentRunning" -o args= | awk '{print $NF}')

	# Suspend the running process and resume the suspended process
	kill -STOP "-$recentRunning"
	kill -CONT "-$recentSuspend"
}

numProcs() {
	pgrep -afc "$script $runningRegex"
}

cleanup() {
	trap retypeCMD EXIT
	timeframe="${2:-8hr}"
	files=$(fd -d1 -e part --changed-within "$timeframe") || return

	if [[ -n $files ]]; then
		echo "$files"
		read -p $'\nDelete current file (c), all listed files (a), or none (n)? (c/a/n): '
		case "$REPLY" in
			c|C)
				delCurrFile
				scriptPID=$(pgrep -P "$PPID" -ox "$(basename "$0")")
				kill -KILL -"$scriptPID"
				printf "\033]30;ch\007"
				;;
			a|A)
				echo "$files" | xargs -d '\n' rm -v
				pkill -KILL "$(basename "$0")"
				;;
			*)
				echo "No files deleted."
				;;
		esac
		return
	fi

	echo "No .part files found."
}

delCurrFile() {
	ffmpegPid=$(pstree -p $PPID | rg -o 'ffmpeg\(\d+\)' | head -n1 | rg -o '\d+')

	if [[ -n $ffmpegPid ]]; then
		path=$(lsof -p "$ffmpegPid" | rg '\.part$' | rg -o '/.*\.part$')
		file=$(basename "$path")

		if [[ -n $file ]]; then
			echo "Found file: $file"
			read -r -p "Do you want to delete it? (y/n): " response
			if [[ $response =~ ^[yY]$ ]]; then
				rm -v "$path"
			else
				echo "File not deleted."
			fi
		else
			echo "No .part file found for ffmpeg process."
		fi
	else
		echo "No ffmpeg process found."
	fi
}

retypeCMD() {
	interactiveShell=$(ps -o comm= -p $PPID)

	if [[ $interactiveShell == zsh ]]; then
		xdotool type "$(basename ${BASH_SOURCE}) " && exec zsh
	elif [[ $interactiveShell == bash ]]; then
		xdotool type "$(basename ${BASH_SOURCE}) " & disown
	fi
}

showTempFiles() {
	fd -d1 -e part --changed-within 1d -x du -h | sort -hr
}

hasDiskSpace() {
	local video availableSpace cushion=104857600 # 100MB in bytes
	video=$(fd -e part --changed-within 1d -x du -b | awk '{sum+=$1} END {print sum+0}')
	availableSpace=$(df --block-size=1 "$(pwd)" --output=avail | tail -n1)

	if ((video + cushion < availableSpace)); then
		return 0
	else
		local requiredSpace=$((video + cushion - availableSpace))
		echo -e "Insufficient disk space. Please free up $((requiredSpace / 1048576)) MB.\n"
		showTempFiles
		return 1
	fi
}

killProcess() {
	if pid=$(pgrep -P $PPID -f "$0.*http"); then
		kill -CONT "-$pid"
		kill -INT "-$pid"

		while kill -0 "$pid" 2>/dev/null; do
			sleep 0.1
		done

		clear
	else
		echo "No $0 download running in current shell"
	fi
}

requires yt-dlp

if [ $# -lt 1 ]; then
	echo "Try '$script -h' for more information."
	exit 2
fi

if [[ ! -f $runningRegexFile ]]; then
	printf "%s\n" "$runningRegex" > "$runningRegexFile"
fi

while [ $# -gt 0 ]; do
	case $1 in
	-s | --suspended)
		numprocs=$(numProcs)
		((numprocs == 0))  && echo "No processes running." && exit
		if ((numprocs == 1)); then
			echo "1 total process."
		else
			echo "$numprocs total processes."
		fi
		ps -ww -o pid=,user=,state=,args:100 -C "$script" | grep -P "$script $runningRegex" | awk '{print $1, $3, $NF}' | sort -k2,2 -k1,1n -b | column -t
		exit
		;;
	--recent)
		read -r recentRunning recentSuspend penultimateRunning <<< "$(getRecentProcessStates)"
		runningProcessName=$(ps -p "$recentRunning" -o args= 2>/dev/null | awk '{print $NF}')
		suspendedProcessName=$(ps -p "$recentSuspend" -o args= 2>/dev/null | awk '{print $NF}')
		penultimateRunningProcessName=$(ps -p "$penultimateRunning" -o args= 2>/dev/null | awk '{print $NF}')
		printf "%17s  %s\n" "recent Run:" "$runningProcessName"
		printf "%17s  %s\n" "penultimate Run:" "$penultimateRunningProcessName"
		printf "%17s  %s\n" "recent Suspended:" "$suspendedProcessName"
		exit
		;;
	--resume)
		read -r _ recentSuspend _ <<< "$(getRecentProcessStates)"
		kill -CONT "-$recentSuspend"
		exit
		;;
	-k | --killall)
		suspended-control -k "$script"
		exit
		;;
	--kill)
		killProcess
		xdotool type "$script "
		exec $SHELL
		exit
		;;
	-f | --forcekill)
		if hasDiskSpace; then
			suspended-control -p "$script"
			suspended-control -k "$script" && exit 0 || exit 1
		fi
		exit
		;;
	--pauseall)
		suspended-control -p "$script"
		exit
		;;
	-p | --pause)
		read -r recentRunning _ _ <<< "$(getRecentProcessStates)"
		kill -STOP "-$recentRunning"
		exit
		;;
	-P | --pause-previous)
		read -r _ _ penultimateRunning <<< "$(getRecentProcessStates)"
		kill -STOP "-$penultimateRunning"
		exit
		;;
	--swap)
		swapActiveSuspended
		exit
		;;
	-g | --grep)
		regex=$2
		if [[ -z $regex ]]; then
			echo "Option $1 requires an argument."
			exit 1
		fi
		yt -s | sort -k6 | grep -P "$regex"
		exit
		;;
	-b | --batch-file)
		path=$2
		if [[ -z $path ]]; then
			echo "Option $1 requires an argument."
			exit 1
		fi
		batchDownload "$path"
		exit
		;;
	-r | --resolution)
		resolution=$2
		shift
		;;
	-c | --cookies)
		cookies=true
		;;
	-d | --del)
		cleanup "$@"
		clear
		exit
		;;
	-h | --help)
		usage
		exit
		;;
	--recent-pids)
		getRecentProcessStates
		exit
		;;
	-t | --show-temp)
		showTempFiles
		exit
		;;
	*)
		url=$1
	esac
	shift
done

if isYoutubeURL "$url"; then
	downloadWithQuality
	exit
fi

download "$url"
